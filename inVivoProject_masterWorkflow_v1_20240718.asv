% Master workflow to reproduce all analysis and plots included in Anja
% Payne's in vivo paper
% Written by Anja Payne
% Last modified: 08/15/2024

% Issues to resolve/currently working on:
%   - Rerun from getThetaModulation so that we can also save the in-field
%     position

% Steps:
%   1) Define pathway [done]
%   2) Read in excel files and create the main data structure [done]
%   3) Split the data into WT and KO [done]
%   4) Save the spike times in msec aligned to 0 [done]
%   5) Exclude spikes that occur during low velocity and format so that the
%      spikes are split by direction and trial number [done]
%   6) Get the rate maps [done]
%   7) Using firing rates, divide data into high-firing (putative place
%      cells) and low-firing [done]
%   8) Get spatial metrics and field barcode [done]
%   9) Get the in-field spikes [done]
%   10) Additional rate map analysis on the high-firing and low-firing and
%       in-field firing [skipping for now]
%   11) Placeholder for all the stability analysis [skipping for now]
%   12) Get the theta modulation
%   13) Get the phase precession

% Notes about this code:
%   - When you choose to save processed data (as prompted by the pop-up
%     window(s), the .mat file will always be saved with increasing 
%     versions and with the data appended.
%   - Each step will give you the option of saving the output. The next 
%     step will look for that saved file so it's a good idea to save as you
%     go. The code will save two files, one with the data and one with the
%     settings. 

%% Step 1: Define pathways
addpath(genpath('Z:\Anja\Paper\Matlab Code')); 

%% Step 2: Read in excel files and create the main data structure
clear;clc;

% Inputs:
excelFolder = 'Z:\Anja\Data\In Vivo Data\AnimalInfo_ExcelFiles\'; 
excelFiles = {'AP_AnimalData_Cohort13_Track', 'AP_AnimalData_Cohort14_Track'}; 

% Outputs: 
mainDataStructure = getDataStructure_v1_20240718(excelFiles, excelFolder); 

%% Step 3: Split the file paths into WT and KO
clear;clc;

% Inputs: 
fileNameBase = 'mainDataStructure'; 
filePath = getMostRecentFilePath_v1_20240723(fileNameBase);
loadFileName = [fileNameBase, '_v', filePath{2}, filePath{3}];
load([filePath{1}, '\', loadFileName]);
[processedDataFolder, ~, ~] = fileparts(filePath{1});
mainDataStructure = data;

% Settings
mainDataStructureSettings = struct(); 

% Outputs: 
filePaths = splitWTandKO_v1_20240722(mainDataStructure, mainDataStructureSettings, processedDataFolder); 

%% Step 4: Save the spike times (takes ~4 min)
clear;clc; tic; 

% Inputs: 
fileNameBase = 'filePathsByGenotype';
filePath = getMostRecentFilePath_v1_20240723(fileNameBase);
loadFileName = [fileNameBase, '_v', filePath{2}, filePath{3}];
load([filePath{1}, '\', loadFileName]);
[processedDataFolder, ~, ~] = fileparts(filePath{1});
filePaths = data; 

% Settings: 
filePathSettings = settings;

% Outputs: 
spikeTimes = getSpikeTimes_v1_20240725(filePaths, filePathSettings, processedDataFolder); toc

%% Step 5: Exclude spikes that occur during low velocity (takes ~55 min)
clear;clc;tic;

% Inputs: 
fileNameBase = 'spikeTimes';
filePath = getMostRecentFilePath_v1_20240723(fileNameBase);
loadFileName = [fileNameBase, '_v', filePath{2}, filePath{3}];
load([filePath{1}, '\', loadFileName]);
[processedDataFolder, ~, ~] = fileparts(filePath{1});
spikeTimes = data; spikeTimeSettings = settings; 

% Settings: 
spikeTimeSettings = settings;
spikeTimeSettings.velocity.threshold = 2; % velocity threshold = 2 cm/sec
spikeTimeSettings.velocity.samplingRate = 16000; % sampling rate of video recording
spikeTimeSettings.velocity.timeToAverage = 1; % time to average over in seconds when calculating velocity
spikeTimeSettings.rateMaps.trackWidth = 52; % cm; used to convert from pixels to cm
spikeTimeSettings.rateMaps.trackLength = 80; % cm; used to convert from pixels to cm
spikeTimeSettings.rateMaps.binSize = 4; % 4 cm bins

% Outputs: 
binnedSpikesByTrial = getHighVelocitySpikesByTrial_v1_20240725(spikeTimes, spikeTimeSettings, processedDataFolder); toc

%% Step 6: Get the linearized rate maps (takes ~3 min)
clear;clc;tic;

% Input: 
fileNameBase = 'highVelocitySpikeTimes';
filePath = getMostRecentFilePath_v1_20240723(fileNameBase);
loadFileName = [fileNameBase, '_v', filePath{2}, filePath{3}];
load([filePath{1}, '\', loadFileName]);
[processedDataFolder, ~, ~] = fileparts(filePath{1});
binnedSpikesByTrial = data; binnedSpikesByTrialSettings = settings; 

% Settings: 
binnedSpikesByTrialSettings.rateMaps.trackSize = 264; 

% Output: 
rateMaps = calculateRateMap_v1_20240718(binnedSpikesByTrial, binnedSpikesByTrialSettings, processedDataFolder); toc

%% Step 7: Split into high-firing and low-firing cells (takes seconds)
clear;clc;tic;

% Inputs:
fileNameBase = 'rateMaps';
filePath = getMostRecentFilePath_v1_20240723(fileNameBase);
loadFileName = [fileNameBase, '_v', filePath{2}, filePath{3}(1:end-4)];
load([filePath{1}, '\', loadFileName, '.mat']);
[processedDataFolder, ~, ~] = fileparts(filePath{1});
rateMaps = data; rateMapSettings = settings; 

% Settings: 
rateMapSettings.firingRates.meanThresh = 0.1; 
rateMapSettings.firingRates.maxThresh = 1; 

% Outputs:
dataByFiringRate = splitLowAndHighFR_v01_20240802(rateMaps, rateMapSettings, processedDataFolder); toc

%% Step 8: Get spatial metrics and associated barcode (takes seconds)
clear;clc;tic;

% Inputs:
fileNameBase = 'rateMapsByFiringRate';
filePath = getMostRecentFilePath_v1_20240723(fileNameBase);
loadFileName = [fileNameBase, '_v', filePath{2}, filePath{3}(1:end-4)];
load([filePath{1}, '\', loadFileName, '.mat']);
[processedDataFolder, ~, ~] = fileparts(filePath{1});
rateMapByFRStructure = data; rateMapByFRSettings = settings; 

% Settings: 
rateMapByFRSettings.rateMaps.lowThresh = 0.1;  % fields will be counted as contiguous bins above 10% of max
rateMapByFRSettings.rateMaps.highThresh = 0.5; % fields must include one bin that is above 50% of the max

% Outputs:
spatialMetrics = getSpatialMetrics_v1_20240724(rateMapByFRStructure, rateMapByFRSettings, processedDataFolder); toc
    
%% Step 9: Get the in-field spikes for each field (takes seconds)
clear;clc;tic;

% Inputs: 
fileNameBase = 'spatialMetrics';
filePath = getMostRecentFilePath_v1_20240723(fileNameBase);
loadFileName = [fileNameBase, '_v', filePath{2}, filePath{3}];
load([filePath{1}, '\', loadFileName]);
[processedDataFolder, ~, ~] = fileparts(filePath{1});
binnedSpikes = data; binnedSpikeSettings = settings;

% Settings: 

% Outputs: 
inFieldSpkTimes = getInFieldSpikes_v1_20240805(binnedSpikes, binnedSpikeSettings, processedDataFolder); toc

%% Step 10: Additional rate map analysis

%% Step 11: Stability analysis

%% Step 12: Get the theta modulation (takes ~1.5 hours)
clear;clc;tic;
display(['Estimated time to finish is ', datestr(datetime('now')+hours(1.5), 'HH:MM:SS')]); 

% Inputs: 
fileNameBase = 'inFieldSpkTimes';
filePath = getMostRecentFilePath_v1_20240723(fileNameBase);
loadFileName = [fileNameBase, '_v', filePath{2}, filePath{3}];
load([filePath{1}, '\', loadFileName]);
[processedDataFolder, ~, ~] = fileparts(filePath{1});
inFieldSpkTimes = data; inFieldSpkTimesSettings = settings;

% Settings: 
inFieldSpkTimesSettings.theta.frequencyBand = [4,12]; 

% Outputs: 
thetaData = getThetaModulation_v1_20240806(inFieldSpkTimes, inFieldSpkTimesSettings, processedDataFolder); toc

%% Step 13: Get the phase precession (takes ~3 min)
clear;clc;close all; tic;

% Inputs: 
fileNameBase = 'theta';
filePath = getMostRecentFilePath_v1_20240723(fileNameBase);
loadFileName = [fileNameBase, '_v', filePath{2}, filePath{3}];
load([filePath{1}, '\', loadFileName]);
[processedDataFolder, ~, ~] = fileparts(filePath{1});
thetaData = data; thetaSettings = settings;


% Settings: 
thetaSettings.phasePrecession.spatialBinThreshold = 2; % minimum number of spatial bins needed
thetaSettings.phasePrecession.slopeRange = [-2*2*pi:0.001:2*2*pi]; % range of slopes to try to fit (Robert Schmidt, 2009, Single-Trial Place Precession in the Hippocampus)
thetaSettings.phasePrecession.significanceThreshold = 1; % maximum acceptabel significance level of line fit
thetaSettings.phasePrecession.trialThreshold = 5; % minimum number of trials
thetaSettings.phasePrecession.fieldsToAnalyze = 'all fields'; % Could also be 'best field'
thetaSettings.phasePrecession.positionType = 'unbinned';
thetaSettings.phasePrecession.plot = 'yes'; % Determines whether plots will be generated

% Outputs: 
phasePrecessionData = getPhasePrecession_v1_20240806(thetaData, thetaSettings, processedDataFolder); toc 

%% Save figures
settings = thetaSettings; 
data = phasePrecessionData; 

if strcmp(settings.phasePrecession.plot, 'yes') == 1; 

    for iGenotype = 1%:length(fieldnames(data.cellData));
        genotypes = fieldnames(data.cellData); 
        genotypeData = data.cellData.(genotypes{iGenotype}); 

        % Run analysis for high-firing cells only
        FRdata = genotypeData.highFiring;
        for iAnimal = 1%1:length(FRdata); 
            % Skip if empty
            if isempty(FRdata{iAnimal}) == 1; 
                continue
            else
                [~,n] = size(FRdata{iAnimal});
                for iCluster = 2%1:n;
                    % Skip if empty
                    if isempty(FRdata{iAnimal}(iCluster).metaData) == 1; 
                        continue
                    else
                        % Assign variables based on running direction
                        directions = fieldnames(FRdata{iAnimal}(iCluster).spatialMetrics.barcode);
                        for iDir = 1:length(directions);
                            if strcmp(directions(iDir), 'cw') == 1; 
                                spkPhs = FRdata{iAnimal}(iCluster).theta.phases.cw; 
                                spkPos = FRdata{iAnimal}(iCluster).inField.inFieldSpkPos.cw; 
                                fitInfo = FRdata{iAnimal}(iCluster).phasePrecession.fitInfo.cw; 
                                %binnedSpkPos = FRdata{iAnimal}(iCluster).inField.inFieldBinnedSpkPos.cw; 
                            elseif strcmp(directions(iDir), 'ccw') == 1; 
                                spkPhs = FRdata{iAnimal}(iCluster).theta.phases.ccw; 
                                spkPos = FRdata{iAnimal}(iCluster).inField.inFieldSpkPos.ccw; 
                                fitInfo = FRdata{iAnimal}(iCluster).phasePrecession.fitInfo.ccw; 
                                %binnedSpkPos = FRdata{iAnimal}(iCluster).inField.inFieldBinnedSpkPos.ccw; 
                            end
                            % Loop through fields
                            if strcmp(settings.phasePrecession.fieldsToAnalyze, 'all fields') == 1;
                                numFieldsToAnalyze = length(spkPhs); 
                            elseif strcmp(settings.phasePrecession.fieldsToAnalyze, 'best field') == 1;
                                numFieldsToAnalyze = 1; 
                            end
                            slopeMedian = []; subplotCount = 0; 
                            for iField = 1:numFieldsToAnalyze;
                                % Loop through all the trials
                                %slope{iField} = NaN(1,length(spkPhs{iField}));
                                for iTrial = 1:length(spkPhs{iField});
                                    % If there are enough spatial bins
    %                                     if nanmax(binnedSpkPos{iField}{iTrial})-nanmin(binnedSpkPos{iField}{iTrial}) < settings.phasePrecession.spatialBinThreshold; 
    %                                         slope{iField}(iTrial) = NaN; 
    %                                         continue; 
    %                                     else
                                    % If there were spikes in-field that trial
                                    figures.allTrialsFig = figure(1); set(figures.allTrialsFig, 'Position', [100, 100, 1800, 800]); 
                                    if iTrial == 1; clf(figures.allTrialsFig); else hold on; end;
                                    subplotCount = subplotCount + 1;
                                    subplot(ceil(length(spkPhs{iField})/10),10,subplotCount); hold on;
                                    

                                    if isempty(spkPhs{iField}{iTrial}) == 0; 
                                        % Get the phase precession for that trial
                                        spkPhsInput = [spkPhs{iField}{iTrial}+pi; spkPhs{iField}{iTrial}+3*pi]; 
                                        spkPhsInput = [spkPhs{iField}{iTrial}+pi; spkPhs{iField}{iTrial}+3*pi]; 
                                        spkPosInput = [spkPos{iField}{iTrial}; spkPos{iField}{iTrial}];
                                        %[cir, lin] = thetaPrecess(spkPhsInput, spkPosInput-min(spkPosInput), settings.phasePrecession.slopeRange); 
                                        %y1 = [cir.Phi0, cir.Phi0+cir.Alpha];

%                                         spkPosPlot = (spkPosInput + 180) * 0.1778; % converts from angular position to centimeters
%                                         scatter(spkPosPlot-min(spkPosPlot), (spkPhsInput/pi), 200, '.k');
                                        %scatter(spkPosInput-min(spkPosInput), (spkPhsInput)/pi, 200, '.k');
                                        scatter(spkPosInput-min(spkPosInput), (spkPhsInput), 200, '.k');
                                        % If the slope is below the significance
                                        % threshold, save the data
                                        [cir, lin] = thetaPrecess(spkPhsInput, spkPosInput-min(spkPosInput), settings.phasePrecession.slopeRange); 

                                        if isempty(fitInfo(iTrial).cir) == 1;
                                            display('this should be skipped')
                                        elseif isempty(fitInfo(iTrial).cir) == 0;
                                            %if fitInfo(iTrial).cir.pValue < settings.phasePrecession.significanceThreshold;
                                                display('in the loop')
        %                                                 trialSlope = (y1(2) - y1(1))/(max(spkPos{iField}{iTrial})-min(spkPos{iField}{iTrial}));
        %                                                 slope{iField}(iTrial) = trialSlope;
                                                xPlot = [0:max(spkPos{iField}{iTrial})-min(spkPos{iField}{iTrial})+1];
                                                %xPlot = [0:ceil(max(spkPosPlot))-floor(min(spkPosPlot))];
                                                %xPlot = [0:(max(spkPosPlot))-(min(spkPosPlot))];
                                                %xPlot = [0, max(spkPos{iField}{iTrial})-min(spkPos{iField}{iTrial})];
                                                %yPlot1 = (xPlot*(lin.Alpha/pi)+lin.Phi0/pi)-1;
                                                yPlot1 = (xPlot*(lin.Alpha)+lin.Phi0)-1;
                                                %yPlot1 = [fitInfo(iTrial).cir.Phi0, fitInfo(iTrial).cir.Phi0+fitInfo(iTrial).cir.Alpha];
                                                %yPlot2 = (xPlot*(lin.Alpha/pi)+lin.Phi0/pi)+1;
                                                %plot(xPlot, yPlot1, 'r');
                                                %plot(xPlot, yPlot2, 'r');
                                                %yPlot = [fitInfo(iTrial).cir.Phi0, fitInfo(iTrial).cir.Phi0+fitInfo(iTrial).cir.Alpha]
                                                plot(xPlot, yPlot1, 'r');
                                                %plot(xPlot, yPlot2, 'r');
                                                set(gca, 'FontSize', 12);
                                                title(num2str(iTrial)); 
                                                if length(xPlot>1); xlim([min(xPlot), max(xPlot)]); end
                                                %ax = gca;  % Get current axes handle
                                                %set(ax, 'XTick', xPlot([1,end]));  % Adjust to match the number of points
                                                %xTickLabels = arrayfun(@num2str, spkPosPlot([1,end]), 'UniformOutput', false)
                                                %set(ax, 'XTickLabel', xTickLabels([1,end]));  % Adjust to match the number of points
                                            %else
                                                %continue;
        %                                                 slope{iField}(iTrial) = NaN; 
                                            %end
                                        end
                                    end
                                end
                                han = axes('Position', [0.13 0.13 0.8 0.8], 'Visible', 'off');
                                han.YLabel.Visible = 'on';
                                ylabel(han, 'Theta Phase (radians)', 'FontSize', 20);
                                han = axes('Position', [0.065 0.10 0.9 0.9], 'Visible', 'off');
                                han.XLabel.Visible = 'on';
                                xlabel(han, 'Linear Position (cm)', 'FontSize', 20);
                                annotation('textbox', [0.02, 0, 0.2, 0.03], 'String', ...
                                    'Data File:', 'FitBoxToText', 'on', 'BackgroundColor', 'none', ...
                                    'EdgeColor', 'none');
                                annotation('textbox', [0.9, 0, 0.2, 0.03], 'String', ...
                                    ['Median Slope: ', num2str(slopeMedian)], 'FitBoxToText', 'on', ...
                                    'BackgroundColor', 'none', 'EdgeColor', 'none');
                            end
                        end
                    end
                end
            end
        end
    end
end
%%
clc; field = 1; trial = 1; 
spkPhs = FRdata{1}(2).theta.phases.cw; 
spkPos = FRdata{1}(2).inField.inFieldSpkPos.cw; 
figure(2); clf; hold on;
spkPhsInput = [spkPhs{field}{trial}+pi; spkPhs{1}{trial}+3*pi];
%spkPosInput = [spkPos{1}{1}; spkPos{1}{1}];
spkPosInput = [spkPos{field}{trial}-min(spkPos{field}{trial}); spkPos{field}{trial}-min(spkPos{field}{trial})];
%posRange = max(spkPos{1}{1})-min(spkPos{1}{1}); 
%spkPosInput = [(spkPos{1}{1}-min(spkPos{1}{1}))/posRange; (spkPos{1}{1}-min(spkPos{1}{1}))/posRange];
scatter(spkPosInput, spkPhsInput); 

%alpha = fitInfo(1).cir.Alpha;
%phi = fitInfo(1).cir.Phi0;
%x = [spkPosInput(1),spkPosInput(end)];
%y = 2*pi*alpha*x + phi;
%plot(x,y)
xPlot = [0:max(spkPosInput)-min(spkPosInput)+1];
yPlot1 = (xPlot*(fitInfo(trial).lin.Alpha/pi)+fitInfo(trial).lin.Phi0/pi)-1;
yPlot2 = (xPlot*(fitInfo(trial).lin.Alpha/pi)+fitInfo(trial).lin.Phi0/pi)+1;
plot(xPlot, yPlot1)
%%

% If plotting, set the overall figure
% settings
% If user specified, plot
if strcmp(settings.phasePrecession.plot, 'yes') == 1; 
    figures.allTrialsFig = figure(1); set(figures.allTrialsFig, 'Position', [100, 100, 1800, 800]); 
    
    if iTrial == 1; clf(figures.allTrialsFig); else hold on; end;
    subplot(ceil(length(spkPhs{iField})/10),10,subplotCount); hold on;
    spkPosPlot = (spkPosInput + 180) * 0.1778; % converts from angular position to centimeters
    scatter(spkPosPlot-min(spkPosPlot), (spkPhsInput/pi), 200, '.k');
    xPlot = [0:ceil(max(spkPosPlot))-floor(min(spkPosPlot))];
    yPlot1 = (xPlot*(lin.Alpha/pi)+lin.Phi0/pi)-1;
    yPlot2 = (xPlot*(lin.Alpha/pi)+lin.Phi0/pi)+1;
    plot(xPlot, yPlot1, 'r');
    plot(xPlot, yPlot2, 'r');
    subplotCount = subplotCount + 1; 
    set(gca, 'FontSize', 12);
    title(num2str(iTrial)); 
    if length(xPlot>1); xlim([min(xPlot), max(xPlot)]); end
    %ax = gca;  % Get current axes handle
    %set(ax, 'XTick', xPlot([1,end]));  % Adjust to match the number of points
    %xTickLabels = arrayfun(@num2str, spkPosPlot([1,end]), 'UniformOutput', false)
    %set(ax, 'XTickLabel', xTickLabels([1,end]));  % Adjust to match the number of points
    han = axes('Position', [0.13 0.13 0.8 0.8], 'Visible', 'off');
    han.YLabel.Visible = 'on';
    ylabel(han, 'Theta Phase (radians)', 'FontSize', 20);
    han = axes('Position', [0.065 0.10 0.9 0.9], 'Visible', 'off');
    han.XLabel.Visible = 'on';
    xlabel(han, 'Linear Position (cm)', 'FontSize', 20);
    annotation('textbox', [0.02, 0, 0.2, 0.03], 'String', ...
        'Data File:', 'FitBoxToText', 'on', 'BackgroundColor', 'none', ...
        'EdgeColor', 'none');
    annotation('textbox', [0.9, 0, 0.2, 0.03], 'String', ...
        ['Median Slope: ', num2str(slopeMedian)], 'FitBoxToText', 'on', ...
        'BackgroundColor', 'none', 'EdgeColor', 'none');
end


