function data = controlPhasePrecession_v1_20250228(data, settings)
    % Generates plots related to phase precession analysis
    % Written by Anja Payne
    % Last Modified: 03/11/2025
    
    % Inputs:
    %   1) data: the matlab structure where the in-field theta phases
    %      by-trial are saved
    %   2) settings: the settings file where the settings for the phase
    %      precession calculations are saved

    % Outputs:
    %   
    %     
    
    % Steps/Figures:
    %   1) Get the average size of the field for each cell that was
    %      included in the phase precession slope analysis
    %   2) Match the distributions of the place field sizes then compare 
    %      the slopes
    
    
    %% Step 1: Get the average place field size
    for iGenotype = 1:length(fieldnames(data.cellData));
        genotypes = fieldnames(data.cellData); 
        genotypeData = data.cellData.(genotypes{iGenotype}); 
        allFieldSizes = []; 
        
        % Run analysis for high-firing cells only
        FRdata = genotypeData.highFiring;
        for iAnimal = 1:length(FRdata); 
            % Skip if empty
            if isempty(FRdata{iAnimal}) == 1; 
                continue
            else
                [~,n] = size(FRdata{iAnimal});
                for iCluster = 1:n;
                    % Skip if empty
                    if isempty(FRdata{iAnimal}(iCluster).metaData) == 1; 
                        display(['Cluster ', num2str(iCluster) ' of animal ', num2str(iAnimal), ' is empty, skipping']);
                        continue
                    else
                        display(['Calculating for cluster ', num2str(iCluster) ' of animal ', num2str(iAnimal)]);
                        
                        % Assign variables based on running direction
                        directions = fieldnames(FRdata{iAnimal}(iCluster).spatialMetrics.barcode.original);
                        for iDir = 1:length(directions);
                            % Loop through fields
                            fieldsToAnalyze = settings.phasePrecession.fieldsToAnalyze; 
                            if strcmp(fieldsToAnalyze, 'all fields') == 1;
                                numField = length(FRdata{iAnimal}(iCluster).spatialMetrics.spatialMetrics.PFsize.(directions{iDir})); 
                            elseif strcmp(fieldsToAnalyze, 'best field') == 1;
                                numField = 1; 
                            end
                            
                            for iField = 1:numField;
                                singleFieldSize = FRdata{iAnimal}(iCluster).spatialMetrics.PFsize.(directions{iDir})(iField);  
                                allFieldSizes = [allFieldSizes, singleFieldSize];
                            end
                        end
                    end
                end
            end
        end
        data.populationData(iGenotype).phasePrecession.averageFieldSizes = allFieldSizes;
    end
    
    %% Step 2: Match the distributions of the place field sizes then compare the slopes
    
    for iGenotype = 1:length(data.populationData)
        
        % Sort by size and apply the same sorting to the slope vector
        [sortedSizes{iGenotype}, sortedSize_idx] = sort(data.populationData(iGenotype).phasePrecessionMedianFieldSizes);
        sortedSlopes{iGenotype} = data.populationData(iGenotype).phasePrecessionSlopes(sortedSize_idx);
        
        % Bin the size vector up
        edgeValues = [0:4:max(sortedSizes{1})];
        [sizeHistogramValues(iGenotype, :), ~] = histcounts(sortedSizes{iGenotype}, edgeValues);
        
    end
    
    % Set random seed for reproducibility
    rng('shuffle');

    % Initialize variables
    numIterations = 100;
    maxN = length(sizeHistogramValues);
    edgeValues = [0:4:max(sortedSizes{1})];

    % Preallocate results
    p_slope = zeros(numIterations, 1);
    p_size = zeros(numIterations, 1);

    % Loop through random iterations
    for iRandomIteration = 1:numIterations
        DSsize = [];
        DSslope = [];

        % Loop through each bin
        for iHistBin = 1:maxN-1
            % Find indices of values within the current bin
            WTindex = find(sortedSizes{1} >= edgeValues(iHistBin) & sortedSizes{1} < edgeValues(iHistBin+1));
            KOindex = find(sortedSizes{2} >= edgeValues(iHistBin) & sortedSizes{2} < edgeValues(iHistBin+1));

            % Downsample WT if there are more WT values than KO
            if length(WTindex) > length(KOindex)
                randomWTindex = randperm(length(WTindex), length(KOindex));
                DSsize = [DSsize, sortedSizes{1}(WTindex(randomWTindex))];
                DSslope = [DSslope, sortedSlopes{1}(WTindex(randomWTindex))];
            % Downsample KO if there are more KO values than WT
            elseif length(KOindex) > length(WTindex)
                randomKOindex = randperm(length(KOindex), length(WTindex));
                DSsize = [DSsize, sortedSizes{2}(KOindex(randomKOindex))];
                DSslope = [DSslope, sortedSlopes{2}(KOindex(randomKOindex))];
            % If the sizes are equal, just append all values
            else
                DSsize = [DSsize, sortedSizes{1}(WTindex)];
                DSslope = [DSslope, sortedSlopes{1}(WTindex)];
                DSsize = [DSsize, sortedSizes{2}(KOindex)];
                DSslope = [DSslope, sortedSlopes{2}(KOindex)];
            end
        end

        % Perform KS test for slopes and sizes
        [~, p_slope(iRandomIteration)] = kstest2(DSslope, sortedSlopes{2});
        [~, p_size(iRandomIteration)] = kstest2(DSsize, sortedSizes{2});
        
    end
    
    figure; cdfplot(p_slope); 
    figure; cdfplot(p_si
end
    
    %% Step 2: Match the distributions of the place field sizes then compare the slopes
    %{
    figure; title('original WT slope vs original KO slope'); hold on;
    histogram(data.populationData(1).phasePrecessionSlopes, [-1:0.05:0]); histogram(data.populationData(2).phasePrecessionSlopes, [-1:0.05:0]); 
    for iGenotype = 1:length(data.populationData)
        % Sort sizes in ascending order - check
        % Apply the same sorting to the slopes so the indices match for
        % both - check
        % Bin those up to make a histogram
        % Go through each bin, if there are more WT sizes, discard and
        % vice versa for KO. Discard the same index for the slope. 
        
        % Sort by size and apply the same sorting to the slope vector
        [sortedSizes{iGenotype}, sortedSize_idx] = sort(data.populationData(iGenotype).phasePrecessionMedianFieldSizes);
        sortedSlopes{iGenotype} = data.populationData(iGenotype).phasePrecessionSlopes(sortedSize_idx);
        
        % Bin the size vector up
        edgeValues = [0:4:max(sortedSizes{1})];
        [sizeHistogramValues(iGenotype, :), ~] = histcounts(sortedSizes{iGenotype}, edgeValues);
        %sizeHistogramValues(iGenotype,:) = sizeHistogram.Values;
        
    end
    
    % Go through each bin and match the numbers between WT and KO
    maxN = length(sizeHistogramValues);
    
    for iRandomIteration = 1:100;
        DSsize = []; 
        DSslope = []; 
        for iHistBin = 1:maxN-1;
            % If there are more WT values, then randomly remove some until it
            % matches the KO values. Use the same indices to remove the slopes. 
            if sizeHistogramValues(1, iHistBin) >= sizeHistogramValues(2, iHistBin); 
                OGindex = find(sortedSizes{1} >= edgeValues(iHistBin) & sortedSizes{1} < edgeValues(iHistBin+1));
                randomIndex = randperm(length(OGindex), sizeHistogramValues(2,iHistBin));
                DSsize = [DSsize, sortedSizes{1}(OGindex(randomIndex))];
                DSslope = [DSslope, sortedSlopes{1}(OGindex(randomIndex))]
            elseif sizeHistogramValues(2, iHistBin) > sizeHistogramValues(1, iHistBin); 
                OGindex = find(sortedSizes{2} >= edgeValues(iHistBin) & sortedSizes{2} < edgeValues(iHistBin+1));
                DSsize = [DSsize, sortedSizes{1}(OGindex)];
                DSslope = [DSslope, sortedSlopes{1}(OGindex)]; 
                KOindex = find(sortedSizes{2} >= edgeValues(iHistBin) & sortedSizes{2} < edgeValues(iHistBin+1));
                valueDiff = sizeHistogramValues(2, iHistBin) - sizeHistogramValues(1, iHistBin);
                if isempty(KOindex) == 0; 
                    randomKOindex = randperm(length(KOindex), valueDiff);
                    sortedSizes{2}(KOindex(randomKOindex)) = NaN; 
                    sortedSlopes{2}(KOindex(randomKOindex)) = NaN; 
                end
            end
        end
        DSslope
        [~, p_slope(iRandomIteration)] = kstest2(DSslope, sortedSlopes{2});
        [~, p_size(iRandomIteration)] = kstest2(DSsize, sortedSizes{2});
        
        % Save output for plotting one iteration
        if iRandomIteration == 1;
           figure; title('downsampled WT size vs downsampled KO size'); hold on; 
           histogram(DSsize, edgeValues); histogram(sortedSizes{2}, edgeValues); 
           figure; title('downsampled WT size vs original WT size'); hold on;
           histogram(DSsize, edgeValues); histogram(sortedSizes{1}, edgeValues); 
           figure; title('downsampled WT slope vs downsampled KO slope'); hold on; 
           histogram(DSslope, [-1:0.05:0]); histogram(sortedSlopes{2}, [-1:0.05:0]); 
           figure; title('downsampled WT slope vs original WT slope'); hold on;
           histogram(DSslope, [-1:0.05:0]); histogram(sortedSlopes{1}, [-1:0.05:0]); 
        end
        
    end
    
    data.populationData(1).phasePrecessionControl.sizeControl.medianField.pValue_slope = p_slope;
    data.populationData(2).phasePrecessionControl.sizeControl.medianField.pValue_size = p_size;
    
    figure; histogram(p_slope, [0:0.05:1])
    figure; histogram(p_size, [0:0.05:1])

    %}
    
    
    
    
    
end
